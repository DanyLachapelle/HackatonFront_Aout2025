import type { FileItem } from "@/types/file-types"
import { config } from "@/config/environment"

// Types pour les DTOs du backend
interface FileDto {
  id: number
  name: string
  path: string
  contentType: string
  size: number
  isFavorite: boolean
  createdAt: string
  updatedAt: string
  folderId?: number
  folderName?: string
  folderPath?: string
  userId: number
  username: string
}

interface FolderDto {
  id: number
  name: string
  path: string
  parentFolderId?: number
  parentFolderName?: string
  userId: number
  username: string
  isFavorite: boolean
  createdAt: string
  updatedAt: string
}

interface CreateFileRequest {
  parentPath: string
  name: string
  content: string
  userId: number
}

interface CreateFolderRequest {
  parentPath: string
  name: string
  userId: number
}

class FileService {
  private baseUrl = config.apiUrl
  private userId = config.defaultUserId // TODO: R√©cup√©rer depuis l'authentification

  // === CONVERSION DTOs vers FileItem ===
  
  private fileDtoToFileItem(fileDto: FileDto): FileItem {
    const name = fileDto.name || (fileDto.path?.split('/')?.pop() || '')
    const lastDotIndex = name.lastIndexOf('.')
    const extension = lastDotIndex > 0 ? name.substring(lastDotIndex + 1).toLowerCase() : undefined
    return {
      id: fileDto.id.toString(),
      name,
      type: "file",
      path: fileDto.path,
      size: fileDto.size,
      createdAt: fileDto.createdAt,
      modifiedAt: fileDto.updatedAt,
      mimeType: fileDto.contentType,
      extension,
      isFavorite: fileDto.isFavorite
    }
  }

  private folderDtoToFileItem(folderDto: FolderDto): FileItem {
    return {
      id: folderDto.id.toString(),
      name: folderDto.name,
      type: "folder",
      path: folderDto.path,
      size: 0,
      createdAt: folderDto.createdAt,
      modifiedAt: folderDto.updatedAt,
      isFavorite: folderDto.isFavorite
    }
  }

  // === M√âTHODES DE TEST ===

  async testConnection(): Promise<boolean> {
    try {
      console.log('Test de connexion au backend...')
      console.log('URL de base:', this.baseUrl)
      
      const response = await fetch(`${this.baseUrl}/files/folders?path=/&userId=${this.userId}`)
      console.log('R√©ponse du backend:', response.status, response.statusText)
      
      if (response.ok) {
        const data = await response.json()
        console.log('Donn√©es re√ßues:', data)
        return true
      } else {
        console.error('Erreur HTTP:', response.status, response.statusText)
        return false
      }
    } catch (error) {
      console.error('Erreur de connexion:', error)
      return false
    }
  }

  // === GESTION DES FICHIERS ===

  async listFiles(path: string): Promise<FileItem[]> {
    try {
      console.log('üìÑ listFiles appel√© pour le chemin:', path)
      const url = `${this.baseUrl}/files/files?path=${encodeURIComponent(path)}&userId=${this.userId}`
      console.log('üåê URL de la requ√™te:', url)
      const response = await fetch(url)
      console.log('üì° R√©ponse HTTP:', response.status, response.statusText)
      if (!response.ok) throw new Error('Erreur lors du chargement des fichiers')
      const files: FileDto[] = await response.json()
      console.log('üìÑ Donn√©es brutes re√ßues:', files)
      const result = files.map(file => this.fileDtoToFileItem(file))
      console.log('üìÑ Fichiers convertis:', result)
      return result
    } catch (error) {
      console.error('Erreur lors du chargement des fichiers:', error)
      return []
    }
  }

  async listFolders(path: string): Promise<FileItem[]> {
    try {
      console.log('üìÅ listFolders appel√© pour le chemin:', path)
      const url = `${this.baseUrl}/files/folders?path=${encodeURIComponent(path)}&userId=${this.userId}`
      console.log('üåê URL de la requ√™te:', url)
      const response = await fetch(url)
      console.log('üì° R√©ponse HTTP:', response.status, response.statusText)
      if (!response.ok) throw new Error('Erreur lors du chargement des dossiers')
      const folders: FolderDto[] = await response.json()
      console.log('üìÅ Donn√©es brutes re√ßues:', folders)
      const result = folders.map(folder => this.folderDtoToFileItem(folder))
      console.log('üìÅ Dossiers convertis:', result)
      return result
    } catch (error) {
      console.error('Erreur lors du chargement des dossiers:', error)
      return []
    }
  }

  async listAll(path: string): Promise<FileItem[]> {
    try {
      console.log('üîç listAll appel√© pour le chemin:', path)
      const [files, folders] = await Promise.all([
        this.listFiles(path),
        this.listFolders(path)
      ])
      console.log('üìÑ Fichiers r√©cup√©r√©s:', files)
      console.log('üìÅ Dossiers r√©cup√©r√©s:', folders)
      const result = [...folders, ...files].sort((a, b) => {
        // Dossiers en premier, puis par nom
        if (a.type !== b.type) {
          return a.type === 'folder' ? -1 : 1
        }
        return a.name.localeCompare(b.name)
      })
      console.log('‚úÖ R√©sultat final listAll:', result)
      return result
    } catch (error) {
      console.error('Erreur lors du chargement des √©l√©ments:', error)
      return []
    }
  }

  async createFolder(parentPath: string, name: string): Promise<void> {
    try {
      const request: CreateFolderRequest = {
        parentPath,
        name,
        userId: this.userId
      }
      
      const response = await fetch(`${this.baseUrl}/files/folders`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(request)
      })
      if (!response.ok) throw new Error('Erreur lors de la cr√©ation du dossier')
    } catch (error) {
      console.error('Erreur lors de la cr√©ation du dossier:', error)
      throw error
    }
  }

  // M√©thode alternative pour compatibilit√© avec le menu contextuel
  async createFolderWithObject(request: { name: string; path: string; userId: number }): Promise<void> {
    try {
      console.log('Tentative de cr√©ation de dossier:', request)
      console.log('URL de l\'API:', `${this.baseUrl}/files/folders`)
      
      const folderRequest: CreateFolderRequest = {
        parentPath: request.path,
        name: request.name,
        userId: request.userId
      }
      
      console.log('Requ√™te envoy√©e:', folderRequest)
      
      const response = await fetch(`${this.baseUrl}/files/folders`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(folderRequest)
      })
      
      console.log('R√©ponse re√ßue:', response.status, response.statusText)
      
      if (!response.ok) {
        const errorText = await response.text()
        console.error('Erreur HTTP:', response.status, errorText)
        throw new Error(`Erreur lors de la cr√©ation du dossier: ${response.status} ${response.statusText}`)
      }
      
      console.log('Dossier cr√©√© avec succ√®s')
    } catch (error) {
      console.error('Erreur lors de la cr√©ation du dossier:', error)
      throw error
    }
  }

  async createFile(parentPath: string, name: string, content: string): Promise<void> {
    try {
      const request: CreateFileRequest = {
        parentPath,
        name,
        content,
        userId: this.userId
      }
      
      const response = await fetch(`${this.baseUrl}/files/files`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(request)
      })
      if (!response.ok) throw new Error('Erreur lors de la cr√©ation du fichier')
    } catch (error) {
      console.error('Erreur lors de la cr√©ation du fichier:', error)
      throw error
    }
  }

  // M√©thode alternative pour compatibilit√© avec le menu contextuel
  async createFileWithObject(request: { name: string; path: string; content: string; userId: number }): Promise<void> {
    try {
      const fileRequest: CreateFileRequest = {
        parentPath: request.path,
        name: request.name,
        content: request.content,
        userId: request.userId
      }
      
      const response = await fetch(`${this.baseUrl}/files/files`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(fileRequest)
      })
      if (!response.ok) throw new Error('Erreur lors de la cr√©ation du fichier')
    } catch (error) {
      console.error('Erreur lors de la cr√©ation du fichier:', error)
      throw error
    }
  }

  async uploadFile(parentPath: string, file: File): Promise<void> {
    try {
      console.log(`üì§ Service: Upload de "${file.name}" vers ${parentPath}`)
      console.log(`üìã D√©tails du fichier:`, {
        name: file.name,
        type: file.type,
        size: file.size,
        lastModified: new Date(file.lastModified),
        extension: file.name.split('.').pop()?.toLowerCase()
      })
      
      // V√©rifier si le contentType est correct pour les images
      if (file.name.toLowerCase().endsWith('.png') && file.type !== 'image/png') {
        console.warn(`‚ö†Ô∏è Type MIME incorrect pour PNG: "${file.type}" au lieu de "image/png"`)
      }
      if (file.name.toLowerCase().endsWith('.jpg') && file.type !== 'image/jpeg') {
        console.warn(`‚ö†Ô∏è Type MIME incorrect pour JPG: "${file.type}" au lieu de "image/jpeg"`)
      }
      
      const formData = new FormData()
      formData.append('file', file)
      formData.append('parentPath', parentPath)
      formData.append('userId', this.userId.toString())
      
      // Log des param√®tres FormData pour debug
      console.log(`üì§ Param√®tres FormData:`)
      for (const [key, value] of formData.entries()) {
        if (key === 'file') {
          console.log(`  ${key}:`, {
            name: (value as File).name,
            type: (value as File).type,
            size: (value as File).size
          })
        } else {
          console.log(`  ${key}:`, value)
        }
      }
      
      console.log(`üåê Envoi de la requ√™te vers: ${this.baseUrl}/files/files/upload`)
      console.log(`üì§ Param√®tres:`, {
        parentPath,
        userId: this.userId,
        fileName: file.name,
        contentType: file.type
      })
      
      const response = await fetch(`${this.baseUrl}/files/files/upload`, {
        method: 'POST',
        body: formData
      })
      
      console.log(`üì° R√©ponse du serveur:`, response.status, response.statusText)
      
      if (!response.ok) {
        const errorText = await response.text()
        console.error(`‚ùå Erreur HTTP ${response.status}:`, errorText)
        console.error(`üìã Headers de r√©ponse:`, Object.fromEntries(response.headers.entries()))
        
        // Solution temporaire pour diagnostiquer les erreurs 400 avec message vide
        if (response.status === 400 && (!errorText || errorText.trim() === "")) {
          console.error(`üîç DIAGNOSTIC - Erreur 400 avec message vide:`)
          console.error(`  ‚Ä¢ URL: ${this.baseUrl}/files/files/upload`)
          console.error(`  ‚Ä¢ M√©thode: POST`)
          console.error(`  ‚Ä¢ ParentPath: ${parentPath}`)
          console.error(`  ‚Ä¢ UserId: ${this.userId}`)
          console.error(`  ‚Ä¢ FileName: ${file.name}`)
          console.error(`  ‚Ä¢ FileType: ${file.type}`)
          console.error(`  ‚Ä¢ FileSize: ${file.size}`)
          console.error(`  ‚Ä¢ ContentType: ${file.type}`)
          console.error(`  ‚Ä¢ Extension: ${file.name.split('.').pop()?.toLowerCase()}`)
          
          // V√©rifier si c'est un probl√®me de contentType
          const extension = file.name.split('.').pop()?.toLowerCase()
          if (extension === 'png' && file.type !== 'image/png') {
            console.error(`  ‚ö†Ô∏è PROBL√àME D√âTECT√â: Type MIME incorrect pour PNG`)
            console.error(`     Attendu: image/png, Re√ßu: ${file.type}`)
          }
          
          // V√©rifier si c'est un probl√®me de dossier syst√®me
          if (parentPath === '/images' && !file.type?.startsWith('image/')) {
            console.error(`  ‚ö†Ô∏è PROBL√àME D√âTECT√â: Type non autoris√© dans /images`)
            console.error(`     Dossier: ${parentPath}, Type: ${file.type}`)
          }
        }
        
        // Analyser l'erreur pour donner plus de d√©tails
        let errorMessage = `Erreur lors de l'upload du fichier: ${response.status} ${response.statusText}`
        
        if (response.status === 400) {
          if (errorText.includes("Type de fichier non autoris√©")) {
            errorMessage = `Type de fichier non autoris√© dans ce dossier.\n\nFichier: ${file.name}\nType MIME: ${file.type}\nDossier: ${parentPath}`
          } else if (errorText.includes("existe d√©j√†")) {
            errorMessage = `Un fichier avec le nom "${file.name}" existe d√©j√† dans ce dossier.`
          } else if (errorText.includes("Dossier parent non trouv√©")) {
            errorMessage = `Le dossier de destination "${parentPath}" n'existe pas ou n'est pas accessible.`
          } else if (errorText.trim() === "") {
            errorMessage = `Erreur 400 - Requ√™te invalide.\n\nD√©tails:\n‚Ä¢ Fichier: ${file.name}\n‚Ä¢ Type MIME: ${file.type}\n‚Ä¢ Taille: ${file.size} bytes\n‚Ä¢ Dossier: ${parentPath}\n‚Ä¢ Message d'erreur: Aucun d√©tail fourni par le serveur\n\nDiagnostic:\n‚Ä¢ Extension: ${file.name.split('.').pop()?.toLowerCase()}\n‚Ä¢ ContentType attendu pour PNG: image/png\n‚Ä¢ ContentType re√ßu: ${file.type}`
          } else {
            errorMessage = `Erreur 400: ${errorText}`
          }
        } else if (errorText.includes("Type de fichier non autoris√©")) {
          errorMessage = `Type de fichier non autoris√© dans ce dossier.\n\nFichier: ${file.name}\nType MIME: ${file.type}\nDossier: ${parentPath}`
        } else if (errorText.includes("existe d√©j√†")) {
          errorMessage = `Un fichier avec le nom "${file.name}" existe d√©j√† dans ce dossier.`
        } else if (errorText.includes("Dossier parent non trouv√©")) {
          errorMessage = `Le dossier de destination "${parentPath}" n'existe pas ou n'est pas accessible.`
        }
        
        throw new Error(errorMessage)
      }
      
      const result = await response.json()
      console.log(`‚úÖ Upload r√©ussi:`, result)
    } catch (error) {
      console.error('‚ùå Erreur lors de l\'upload du fichier:', error)
      throw error
    }
  }

  async getFileContent(path: string): Promise<string> {
    try {
      const response = await fetch(`${this.baseUrl}/files/files/content?path=${encodeURIComponent(path)}&userId=${this.userId}`)
      if (!response.ok) throw new Error('Erreur lors de la lecture du fichier')
      return await response.text()
    } catch (error) {
      console.error('Erreur lors de la lecture du fichier:', error)
      throw error
    }
  }

  async updateFileContent(path: string, content: string): Promise<void> {
    try {
      const response = await fetch(`${this.baseUrl}/files/files/content?path=${encodeURIComponent(path)}&content=${encodeURIComponent(content)}&userId=${this.userId}`, {
        method: 'PUT'
      })
      if (!response.ok) throw new Error('Erreur lors de la mise √† jour du fichier')
    } catch (error) {
      console.error('Erreur lors de la mise √† jour du fichier:', error)
      throw error
    }
  }

  // Fallback move/copy tant que le backend n'expose pas d'endpoint d√©di√©
  async moveOrCopyFile(sourcePath: string, targetDir: string, action: 'copy' | 'move'): Promise<void> {
    // T√©l√©charger contenu puis recr√©er (texte uniquement pour l'instant)
    const content = await this.getFileContent(sourcePath)
    let name = sourcePath.split('/').pop() || 'fichier'
    
    // Forcer l'extension .txt pour les fichiers texte
    if (!name.toLowerCase().endsWith('.txt')) {
      name += '.txt'
    }
    
    await this.createFile(targetDir, name, content)
    if (action === 'move') {
      await this.deleteFile(sourcePath)
    }
  }

  async deleteFile(path: string): Promise<void> {
    try {
      const response = await fetch(`${this.baseUrl}/files/files?path=${encodeURIComponent(path)}&userId=${this.userId}`, {
        method: 'DELETE'
      })
      if (!response.ok) throw new Error('Erreur lors de la suppression')
    } catch (error) {
      console.error('Erreur lors de la suppression:', error)
      throw error
    }
  }

  async deleteFileById(id: string): Promise<void> {
    try {
      const response = await fetch(`${this.baseUrl}/files/files/${id}?userId=${this.userId}`, {
        method: 'DELETE'
      })
      if (!response.ok) throw new Error('Erreur lors de la suppression du fichier')
    } catch (error) {
      console.error('Erreur lors de la suppression du fichier:', error)
      throw error
    }
  }

  async deleteFolder(id: string): Promise<void> {
    try {
      const response = await fetch(`${this.baseUrl}/files/folders/${id}?userId=${this.userId}`, {
        method: 'DELETE'
      })
      if (!response.ok) throw new Error('Erreur lors de la suppression du dossier')
    } catch (error) {
      console.error('Erreur lors de la suppression du dossier:', error)
      throw error
    }
  }

  async renameFile(id: string, newName: string): Promise<void> {
    try {
      const response = await fetch(`${this.baseUrl}/files/files/${id}/rename`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ newName, userId: this.userId })
      })
      if (!response.ok) throw new Error('Erreur lors du renommage du fichier')
    } catch (error) {
      console.error('Erreur lors du renommage du fichier:', error)
      throw error
    }
  }

  async renameFolder(id: string, newName: string): Promise<void> {
    try {
      const response = await fetch(`${this.baseUrl}/files/folders/${id}/rename`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ newName, userId: this.userId })
      })
      if (!response.ok) throw new Error('Erreur lors du renommage du dossier')
    } catch (error) {
      console.error('Erreur lors du renommage du dossier:', error)
      throw error
    }
  }

  async downloadFile(path: string): Promise<Blob> {
    try {
      const response = await fetch(`${this.baseUrl}/files/download?path=${encodeURIComponent(path)}&userId=${this.userId}`)
      if (!response.ok) throw new Error('Erreur lors du t√©l√©chargement')
      return await response.blob()
    } catch (error) {
      console.error('Erreur lors du t√©l√©chargement:', error)
      throw error
    }
  }

  // === GESTION DES FAVORIS ===

  async getFavoriteFiles(): Promise<FileItem[]> {
    try {
      const response = await fetch(`${this.baseUrl}/files/files/favorites?userId=${this.userId}`)
      if (!response.ok) throw new Error('Erreur lors du chargement des favoris')
      const files: FileDto[] = await response.json()
      return files.map(file => this.fileDtoToFileItem(file))
    } catch (error) {
      console.error('Erreur lors du chargement des favoris:', error)
      return []
    }
  }

  async getFavoriteFolders(): Promise<FileItem[]> {
    try {
      const response = await fetch(`${this.baseUrl}/files/folders/favorites?userId=${this.userId}`)
      if (!response.ok) throw new Error('Erreur lors du chargement des favoris')
      const folders: FolderDto[] = await response.json()
      return folders.map(folder => this.folderDtoToFileItem(folder))
    } catch (error) {
      console.error('Erreur lors du chargement des favoris:', error)
      return []
    }
  }

  async toggleFileFavorite(path: string): Promise<void> {
    try {
      const response = await fetch(`${this.baseUrl}/files/files/favorite`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ path, userId: this.userId })
      })
      if (!response.ok) throw new Error('Erreur lors du basculement du favori')
    } catch (error) {
      console.error('Erreur lors du basculement du favori:', error)
      throw error
    }
  }

  async toggleFolderFavorite(path: string): Promise<void> {
    try {
      const response = await fetch(`${this.baseUrl}/files/folders/favorite`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ path, userId: this.userId })
      })
      if (!response.ok) throw new Error('Erreur lors du basculement du favori')
    } catch (error) {
      console.error('Erreur lors du basculement du favori:', error)
      throw error
    }
  }

  // === RECHERCHE ===

  async searchFiles(query: string): Promise<FileItem[]> {
    try {
      const response = await fetch(`${this.baseUrl}/files/search?query=${encodeURIComponent(query)}&userId=${this.userId}`)
      if (!response.ok) throw new Error('Erreur lors de la recherche')
      const files: FileDto[] = await response.json()
      return files.map(file => this.fileDtoToFileItem(file))
    } catch (error) {
      console.error('Erreur lors de la recherche de fichiers:', error)
      return []
    }
  }

  async searchFolders(query: string): Promise<FileItem[]> {
    try {
      const response = await fetch(`${this.baseUrl}/files/folders/search?query=${encodeURIComponent(query)}&userId=${this.userId}`)
      if (!response.ok) throw new Error('Erreur lors de la recherche')
      const folders: FolderDto[] = await response.json()
      return folders.map(folder => this.folderDtoToFileItem(folder))
    } catch (error) {
      console.error('Erreur lors de la recherche de dossiers:', error)
      return []
    }
  }


  async searchFilesByType(contentType: string): Promise<FileItem[]> {
    try {
      const response = await fetch(`${this.baseUrl}/files/search/type?contentType=${encodeURIComponent(contentType)}&userId=${this.userId}`)
      if (!response.ok) throw new Error('Erreur lors de la recherche par type')
      const files: FileDto[] = await response.json()
      return files.map(file => this.fileDtoToFileItem(file))
    } catch (error) {
      console.error('Erreur lors de la recherche par type:', error)
      return []
    }
  }

  // === APPLICATIONS SP√âCIALIS√âES ===

  async findMusicFiles(): Promise<FileItem[]> {
    try {
      const response = await fetch(`${this.baseUrl}/files/audio?userId=${this.userId}`)
      if (!response.ok) throw new Error('Erreur lors de la recherche de fichiers musicaux')
      const files: FileDto[] = await response.json()
      return files.map(file => this.fileDtoToFileItem(file))
    } catch (error) {
      console.error('Erreur lors de la recherche de fichiers musicaux:', error)
      return []
    }
  }

  async findImageFiles(): Promise<FileItem[]> {
    try {
      const response = await fetch(`${this.baseUrl}/files/images?userId=${this.userId}`)
      if (!response.ok) throw new Error('Erreur lors de la recherche de fichiers images')
      const files: FileDto[] = await response.json()
      return files.map(file => this.fileDtoToFileItem(file))
    } catch (error) {
      console.error('Erreur lors de la recherche de fichiers images:', error)
      return []
    }
  }

  async findTextFiles(): Promise<FileItem[]> {
    try {
      const response = await fetch(`${this.baseUrl}/files/text?userId=${this.userId}`)
      if (!response.ok) throw new Error('Erreur lors de la recherche de fichiers texte')
      const files: FileDto[] = await response.json()
      return files.map(file => this.fileDtoToFileItem(file))
    } catch (error) {
      console.error('Erreur lors de la recherche de fichiers texte:', error)
      return []
    }
  }

  // === UTILITAIRES ===

  async getFolderItemCount(path: string): Promise<number> {
    try {
      const response = await fetch(`${this.baseUrl}/files/count?path=${encodeURIComponent(path)}&userId=${this.userId}`)
      if (!response.ok) throw new Error('Erreur lors du comptage')
      return await response.json()
    } catch (error) {
      console.error('Erreur lors du comptage:', error)
      return 0
    }
  }

  // === M√âTHODES DE V√âRIFICATION (gard√©es pour compatibilit√©) ===

  private isMusicFile(file: FileItem): boolean {
    const musicExtensions = ['.mp3', '.wav', '.flac', '.aac', '.ogg', '.m4a', '.wma']
    const musicMimeTypes = ['audio/mpeg', 'audio/wav', 'audio/flac', 'audio/aac', 'audio/ogg', 'audio/mp4', 'audio/x-ms-wma']
    
    const lastDotIndex = file.name.lastIndexOf('.')
    const extension = lastDotIndex > 0 ? file.name.toLowerCase().substring(lastDotIndex) : ''
    return musicExtensions.includes(extension) || (!!file.mimeType && musicMimeTypes.includes(file.mimeType))
  }

  private isImageFile(file: FileItem): boolean {
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.svg', '.tiff']
    const imageMimeTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/bmp', 'image/webp', 'image/svg+xml', 'image/tiff']
    
    const lastDotIndex = file.name.lastIndexOf('.')
    const extension = lastDotIndex > 0 ? file.name.toLowerCase().substring(lastDotIndex) : ''
    return imageExtensions.includes(extension) || (!!file.mimeType && imageMimeTypes.includes(file.mimeType))
  }
}

export const fileService = new FileService() 